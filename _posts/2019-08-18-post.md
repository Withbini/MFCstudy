---
title: "Windows 시스템 프로그래밍 정리-명령어 구성 및 커널 오브젝트"
date: 2019-08-18
---
들어가기에 앞서 설명할 내용은 컴퓨터구조에서 배웠던 ARM을 바탕으로 한 명령어 개념을 가지고 있으나, 실제 어셈블리 코드와는 다르다는 것을 먼저 알리고자 한다.


컴퓨터 구조-명령어
=====
#### Computer design
만약 컴퓨터를 디자인한다고 했을때 H/W 디자이너(보통의 경우 ASIC), Algorithm 디자이너, Interface 전문가, 프로그램 전문가 등 
다양한 집단의 사람이 참여한다.
이 중 프로그램 전문가는 보통 S/W인데, 이들은 주로 instruction set과 register에 관한 세부사항을 정한다.

### 명령어
명령어의 경우 명령어에 따라 명령어 조합이 달라진다.
예를 들어, 사칙연산 명령어는 "연산자 destination operand1 operand2"로 구성되어
피연산자1과 피연산자2를 연산자에 맞춰 계산하여 destination 으로 보낸다는 의미를 담고 있다.


이 때, destination에 올 수 있는 것은 레지스터뿐이고 피연산자에 들어갈 수 있는 대상은 레지스터와 숫자 둘 다 가능하다.
하지만 레지스터와 숫자에 들어갈 수 있는 수가 제한되어 있다. 또한 메모리주소를 가져와 연산하는 것도 제한되어 있다.
이런 제약을 가진 이유는 이 시스템이 RISC를 따르기 때문이다.
RISC는 명령어의 갯수를 줄이고 여러 제약조건을 가진 대신 "파이프라이닝"을 통해 효율성을 높일 수 있기에 유용하고 지금까지 많은 시스템에서 사용하고 있다.


그렇다면 메모리 주소를 가져와 연산하고 싶은 경우에는 어떻게 해야할까?
이 경우에는 사칙연산과 다른 또다른 연산이 필요하다. 그것이 바로 load&store인데, load와 store를 통해 메모리 주소를 가지고 직접적
연산이 가능하다. 즉 다시 말해서 메인 메모리에서 CPU 레지스터로 데이터를 가져오거나 그 반대의 것이 load&store 연산자를 통해 가능해졌다.
load의 경우 명령어는 "load연산자 destination source"로 표현된다.
이 때 source는 메인 메모리 특정 주소의 데이터를 destination 레지스터로 보낸다는 의미를 가진다.
~~~.asm
LOAD r1 0x100 //256번지 데이터를 r1에 저장하시오
~~~

store의 경우 명령어는 "store연산자 source destination으로 표현된다.
이 때 source는 레지스터의 있는 데이터를 메모리의 특정 주소로 보낸다는 의미를 가지고 있다.
~~~.asm
STORE r1 0x100 //r1데이터를 256번지에 저장하시오
~~~


#### direct VS indirect

메모리 주소 addressing과 관련하여 얘기할 주제는 direct address와 indirect address이다.
direct address는 직접적으로 메모리주소 내 내용을 가져오는 것을 의미한다. rough하게 예를 들어보자.
32비트 시스템에서는
* 2^32=4GB 주소까지 메모리 주소에 접근할 수 있다. 
* 또한 명령어의 길이는 32비트이다.
* load 명령어 source 길이는 32비트보다 작다.

위 사실을 받아들인다면, 메인 메모리의 모든 영역에 접근할 수 없음을 알 수 있다.
source인 메인 메모리의 주소값이 32비트보다 작으므로 4GB보다 작은 숫자의 메모리 주소에 접근할 수 있고,
그보다 큰 숫자의 메모리 주소에는 접근할 수 없다는 의미이다.

direct address 방식은 위와 같은 문제점을 가지고 있다.


그래서 나온것이 바로 indirect 방식이다.
indirect 방식은 direct 방식과 다르게 메모리 주소가 참조하고 있는 메모리 주소가 가진 데이터를 참조한다.
즉, 포인터의 개념이라고 생각하면 될 것이다. 다음과 같은 명령어를 보면 이해가 될 것이다.
~~~.asm
LOAD r1 [0x100] //256번지가 가리키는 메모리 주소의 데이터를 가져와 r1에 저장하시오
~~~

물론 direct 모드로 할 것인지 indirect 모드로 할 것인지에 대한 비트도 필요한 것은 당연하다.



### 프로세스
프로세스는 상태라는 것을 가진다. 이는 여러 프로그램을 한번에 돌리기 위해(실제로는 한번에 하나의 프로그램만 돌리지만) 도입한 개념이다.
기본적으로 running <-> blocked <-> ready 상태를 통해 어떤 프로세스가 현재 실행중에 있고, 어떤 프로세스가 다음 CPU를 차지하고 돌아갈지,
어떤 프로세스가 I/O작업을 기다리는지 등을 프로세스 상태를 통해서 알 수 있다. 그리고 상태전환이 일어나고 CPU 차지하는 프로세스가 바뀌는 것을 Context Switching이라고 한다.


#### 프로세스의 생성
유닉스 계열이든 윈도우즈 계열이든 프로세스는 스스로 생성될 수 없다. 부모 프로세스가 있어 fork()함수(UNIX 계열) CreateProcess(windows계열) 시스템 함수를 통해
자식 프로세스로 복사되면서 생성된다.

여기에서는 CreateProcess에 대해 좀 더 알아보겠다. CreateProcess는 간략하게 다음과 같다.

~~~C++
BOOL CreateProcess(
    LPCTSR lpApplicationName,//창에 표시되는 이름 
    LPTSTR lpCommandLine, //새 프로세스에 인자 전달 
    LPSECURITY_ATTRIBUTES lpProcessAttributes, //프로세스 보안 속성, 보통 NULL
    LPSECURITY_ATTRIBUTES lpThreadAttributes, //스레드 보안 속성, default NULL
    BOOL bInheritHandles, //부모 프로세스 소유 핸들 상속
    DWORD dwCreationFlags, //우선순위같은 특성 지정
    LPVOID lpEnvironment, //environment block 메모리 블록 지정
    LPCTSTR lpCurrentDirectory, //디렉토리 설정, 보통 NULL
    LPSTARTUPINFO lpStartupInfo, //STARTUPINFO 구조체 변수 
    LPPROCESS_INFORMATION lpProcessInformation //생성하는 프로세스 정보 얻기 위해 사용 
)
~~~

여기에서 주목해야할 인자는 lpStartupInfo lpProcessInformation dwCreationFlags 등이다.
lpStartupInfo은 STARTUPINFO 구조체와 관련이 있다. 이는 윈도우 창의 위치와 크기에 관한 정보가 담겨 있다.
lpProcessInformation는 PROCESS_INFORMATION 구조체와 관련이 있는데 커널 오브젝트에서 자세하게 설명할 것이다.
dwCreationFlags 에는 프로세스 생성시 특성을 결정지을 수 있다. 만약 CREATE_NEW_CONSOLE 이라는 flag를 넣는다면
자식 프로세는 새로운 콘솔창에서 생성된다. 



### 커널 오브젝트
먼저 커널이란 운영체제에서 운영체제로서 기본적인 역할을 할 수 있게하는 것을 의미한다. 즉, 운영체제가 운영체제이기 위한 핵심을 말한다.
커널 오브젝트란 그러한 커널에서 관리하는 리소스 정보를 담고 있는 데이터 블록이라고 할 수 있다.
여기서 리소스는 운영체제가 생성하고 소멸시키는 파이프, 프로세스, 스레드, 파일 등이라고 말할 수 있다.

실제로 CreateProcess 함수에 의해 프로세스가 생성되었다고 하면, 그 프로세스에 관한 프로세스 정보들(예를 들어 프로세스 상태정보 등) 또한 있어야하는데 그것이 바로 커널 오브젝트이다.
파일이라면 파일의 위치, 파일의 접근권한 등이 커널 오브젝트에 담겨 있다고 할 수 있다.

물론, 이 커널 오브젝트는 windows 시스템에서 직접 접근할 수 없게 만들었다. 대신, 각 프로세스마다 **핸들**을 두어, 커널 오브젝트의 값을 간접적으로 변경하거나 참조할 수 있게 한다.
이 때, 핸들을 얻는 방법은 리소스마다 다르다. 프로세스의 경우 **HANDLE GetCUrrentProcess(VOID)** 라는 함수를 통해 얻을 수 있다.

#### 커널 오브젝트와 핸들과의 관계
커널 오브젝트는 운영체제에 종속적이다.

핸들은 프로세스에 종속적이다.
핸들은 프로세스마다 존재하며 핸들과 커널 오브젝트가 key, value 관계로 handle table에 명시되어 있다. 이 때 handle table도 프로세스마다 각각 존재한다.
예를 들어 A라는 프로세스 그리고 A에서 생성된 B 프로세스가 있다고 하자.
A프로세스는 자기 자신의 커널 오브젝트를 가리키는 핸들이 하나 있을 것이고 B프로세스를 가리키는 핸들도 있을 것이다. 그리고 이 관계가 A프로세스 handle table에 존재한다.


B 프로세스가 종료된다면 B의 커널 오브젝트는 사라지지 않는다.(windows 정책상) 커널 오브젝트는 운영체제만이 소멸시킬 수 있다. 또한 B 프로세스가 종료되었을 때 A프로세스에서 B프로세스의 커널 오브젝트를
가리키는 key value값이 사라지지 않는다고 하자. 다시 정리하면 B 프로세스 커널 오브젝트에 접근할 수 있는 애는 지금 A 프로세스 하나인데, 언제 운영체제는 B 커널 오브젝트를 소멸시키는가?

이 때 Usage Count라는 개념이 등장한다. 이는 각 커널 오브젝트에 어떤 것들이 접근가능한지 여부를 체크한다. 이번 예제에서는 B프로세스의 경우에는 UC=2, A프로세스의 경우에도 UC=2일 것이다.
(A프로세스도 누군가에게서 나온 자식 프로세스이니까) 하지만 B 프로세스가 종료된다면 B 프로세스의 UC=1이 된다. 그리고 A프로세스에서 CloseHandle() 함수를 사용하면, 
핸들을 반환하면서 B 프로세스의 UC=0이 되고 그제서야 B 프로세스 커널 오브젝트가 소멸된다.

