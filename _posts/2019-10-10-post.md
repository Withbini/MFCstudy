---
title: "Cuda video decoder 렌더링 스레드 해제"
date: 2019-10-10
---

기존의 렌더링 방식은 다음과 같다.  
1. 디먹서, 디코더, 프레젠터 객체를 선언한다.
2. 반복문을 돌며 디코딩된 프레임을 DirectX 디스플레이에 사용할 수 있도록 NV12->RGBA로 바꾼다.
3. 같은 반복문 내에서 RGBA로 바뀐 프레임을 프레젠터로 보여준다.  
(이 부분에서 정확히는 모르겠지만 BGRA로 변환한 프레임을 CUDA로 복사하여 프레젠트에 사용한다.  
아마 DirectX와 Cuda가 같은 메모리공간을 공유하는 것으로 보인다)
4. 1부터 3까지 과정이 한 함수에 들어있고 이 함수를 **채널 갯수만큼** 스레드로 호출한다.

의사코드로 나타내면 다음과 같다.
~~~c++
Decoder(int nth){
	while(채널이 재생이 안끝났다면){
	. . .
	Render(nth channel)
	. . . 
	}
}

. . .

//다른 함수에서
//채널에 파일이 로드될 때마다 스레드를 생성한다.
. . .
if(nth 채널에 파일 로드되면))
thread(Decoder,nth);
. . .
~~~

바뀐 방식은 다음과 같다.
1. 반복문 내에서 파일이 들어온 채널에 한해서 디먹서, 디코더, 프레젠터 객체를 선언한다.
2. 같은 반복문 내에서 파일 로드 완료+파일 재생 중인 채널만 NV12->RGBA로 변환한다.
3. 같은 반복문 내에서 파일 로드 완료+파일 재생 중일 채널만 프레젠터로 보여준다.
4. 1부터 3까지 과정이 한 함수에 들어있고 그 함수는 하나의 스레드로만 동작한다.

위와 같은 방식은 간단하게 말해서 하나의 for문이 있고 렌더링을 여러번한다.
~~~c++
while(모든 채널이 재생이 안끝났다면){
	. . .
	Render(1 channel)
	Render(2 channel)
	Render(3 channel)
	Render(4 channel)
	. . . 
}
~~~


결과적으로 아래 코드가 훨씬 더 잘 작동한다.
첫번째 방식의 문제점은 스레드 수가 너무 많아 Present할 때 시간이 너무 오래 걸린다.
예상하길, 그래픽 카드로 디스플레이 요청할 때 여러 스레드가 한번에 너도나도 요청해서 그런것으로 보인다.
정확한 것은 좀 더 공부해봐야 알겠지만,  
아래처럼 하나의 함수에서 모두다 렌더링했을때에는 훨씬 더 많은 채널을 돌릴 수 있었다.
뿐만 아니라 원래 목표였던 16채널을 넘어서 25채널까지도 가능할 것으로 보인다.

한계점
* NVCUVID가 아닌 NVDEC를 사용하면서 생긴 문제인데, 반복 재생이 불가능하다.
* 전체 재생이 끝날경우, 새로운 파일을 넣어서 재생을 다시 할 수 없다.

결국 재생을 다시 하려면 앱을 다시 켜라는것인데, 매우 불편하다.  
이것을 고칠 방법을 생각해봐야겠다(나중에)


앞으로 할일
---
1. FPS 마무리
2. 처음에 GPU 스펙 받아올때 대략적으로 몇채널까지 사용할 수 있다는 힌트 주기
3. yolo 연결
4. 위의 한계점 해결하기
