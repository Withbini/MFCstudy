---
title: "GPU 변경"
date: 2019-08-12
---

GPU 변경
==============

GPU를 gtx 1080->gtx 1080ti로 바꿨으나, 오히려 4by4 채널에서 돌아가지 않는다.
확인 결과 global total memory가 4기가로 찍히는 문제 발견
생각해보니, 지금 내가 하고 있는 것은 32bit였음. 그래서 최대 4기가 메모리까지밖에 접근 못한다.
64비트 시스템으로 바꾸는 방법 생각해봐야할 것임.

추가적으로 이미지버튼을 어떻게 할지도 고민해야함
MFC 버튼 동적으로 생성하는 방법은 있으나, 동적 생성한 버튼에 이미지를 처음에 씌우는 방법을 어떻게 해야할지 잘 모르겠다...
고민이 많이 필요할 것 같다.

+ 쿠다 라이브러리도 64비트를 써야하나, 32비트를 쓴 것 같다. 이 부분도 확인해봐야한다.


시스템 프로그래밍 공부 시작
=============
KOCW에서 강의를 보려고 했으나, 멀티 스레드까지 가르쳐주는 것은 없는 것 같아 인프런에서 강의를 찾았다.
<https://www.inflearn.com/course/%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D#>
'뇌를 자극하는 윈도우즈 프로그래밍'이라고 윤성우 저자가 쓴 책에 대한 강의이다.
이것도 멀티 스레드까지 알려주는 것 같지는 않으나, 윤성우 강의라는 점에 매우 이끌렸다.
C프로그래밍 책을 굉장히 잘 만든걸로 기억하고 강의또한 매우 우수했다.


강의는 컴퓨터구조 일부, 운영체제 일부, 50%정도 시스템 프로그래밍에 대해 논한다.

### 유니코드
윈도우즈는 일반적으로 유니코드를 지원한다.
그동안 C프로그래밍에서는 아스키코드가 주였다고 한다면, 윈도우즈 프로그래밍은 유니코드가 주라고 한다.

문자 표현방법은 3가지가 있는데 문자 모두 1바이트인 **SBCS** 한글은 2바이트, 영문은 1바이트인 **MBCS** 그리고 문자 모두 2바이트인 **WBCS**가 있다.
WBCS의 종류 중 하나가 유니코드이다. WBCS를 쓰는 이유는 안정성 때문이다. 예를 들어, strlen이라는 함수는 문자의 길이를 출력하는 함수이다. 
하지만 아스키코드에서는 한글이 2바이트로 인식되어, 제대로 된 문자의 길이를 출력할 수 없다. WBCS를 사용하게 되면, 한글이든 영어이든 관계없이 
모두 2바이트이므로 안정적이라고 말한다.

여기서 문제가 있다. 그렇다면 유니코드를 쓰기 위해서 C언어 프로그래밍에서 사용했던 문자열과 관련한 함수(strlen, strcat, strcpy 등)을 바로 쓸 수 있을까?
정답은 아니다. 유니코드와 관련된 자료형이 있고, 함수가 있다.
예를 들어, strlen 대신에 wstrlen, strcpy 대신에 wstrcpy 이런 식이다.

main함수에도 변화가 있다.

~~~C++
int main (int argc, char *argv[]) 
~~~

대신에

~~~C++
int wmain (int argc, wchar_t *argv[]) 
~~~

를 사용한다.


### MBCS WBCS 동시지원
그렇다면 개발자입장에서 개발할 때 아스키코드를 사용할때와 유니코드를 사용할때 두 가지 버전의 프로그램을 만들어야 하는가?
아니다. 이것은 유지보수 측면에서 문제가 있다.

예를 들어, A라는 프로그램을 B버전 C버전 두가지 버전으로 만들었다고 하자.
B에서 문제가 발견되어 수정해보니, C에서도 같은 문제가 발생할 수 있음을 감지했다.
그래서 C도 수정했다. 반대의 경우도 가능하다.

위의 사례처럼 한 버전을 고치면 다른 버전도 고쳐야할 필요가 있다. 그래서 유지 보수 측면에서 문제가 있다고 언급한 것이다.
그렇다면 이 문제를 해결하기 위해 어떻게 해야할까?

다음과 같은 코드를 보자

~~~C++
#ifdef 유니코드로 쓰여있으면
//내가 사용하는 wmain함수는 main이고
//내가 사용하는 wstrlen함수는 strlen이다

#else 유니코드가 아니면
//내가 사용하는 main함수는 그냥 main이고
//내가 사용하는 strlen함수는 그냥 strlen이다
~~~

위와 같이 #ifdef #else를 사용하여 유니코드 사용할 때에는 유니코드 전용으로, 그 반대일 경우에는 일반 함수 및 자료형으로 치환되도록 한다.
코드 수준으로 정리하면 다음과 같다.

~~~C++
typedef _tmain wmain
typedef _tcslen wstrlen
#else
typedef _tmain main
typedef _tcslen strlen
~~~

위 코드에서는 main과 strlen 함수만 가지고 예를 들었으나, msdn을 참고하면 더 많은 함수들이 잘 나와있다.



### 32비트 64비트 시스템
#### 32비트 64비트 나누는 기준
+ 한번에 송수신 가능 데이터 크기(I/O Bus capacity)
+ 데이터 처리능력 (CPU가 한번에 읽을 수 있는 instruction 크기)

#### 32비트에서 메모리가 4GB인 이유
32비트 컴퓨터가 64비트 컴퓨터가 되면서 몇가지 변화가 생겼다.
long 자료형이 4바이트에서 8바이트가 되었고 포인터가 4바이트에서 8바이트가 되었다.
포인터가 4바이트->8바이트가 되었다는 점에 주목할 필요가 있는데, 기존에는 메모리에 접근할 수 있는 주소체계에 한계가 있었다.
무슨말이냐면, 4바이트이므로 2^32 =4GB의 메모리 주소까지만 가질 수 있었다.
그래서 윈도우즈 32비트를 보면 아무리 큰 메모리를 넣어도 4GB까지밖에 인식되지 않는 것이다.

#### 32비트 64비트 공존하기
유니코드처럼 32비트, 64비트 두 시스템이 공존할 필요성이 생겼다.
언급했듯이 32비트 전용 프로그램과 64비트 전용 프로그램을 따로 둔다는 것은 유지보수 측면에서 문제가 있기에
위처럼 전처리기를 활용하여 선언한다.
코드는 다음과 같다.

~~~C++
#ifdef(_WIN64)
typedef unsigned __int64 UINT_PTR
#else
typedef unsigned int UINT_PTR
~~~

시스템 프로그래밍은 강의를 듣고 정리한 것을 바탕으로 계속 써나갈 예정이다. 8월내로는 다 올리는 것을 목표로 한다(15시간 강의니까!)
